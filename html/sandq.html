
<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Data Structures/Stacks and Queues</title>
<link rel="stylesheet" type="text/css" href="../css/stacks_queues.css">
</head>
<h2><span class="mw-headline" id="Stacks_and_Queues">Stacks and Queues</span></h2>
<h3><span class="mw-headline" id="Stacks">Stacks</span></h3>
<p>A stack is a basic data structure that can be logically thought of as a linear structure represented by a real physical stack or pile, a structure where insertion and deletion of items takes place at one end called top of the stack. The basic concept can be illustrated by thinking of your data set as a stack of plates or books where you can only take the top item off the stack in order to remove things from it. This structure is used all throughout programming.
</p><p>The basic implementation of a stack is also called a LIFO (Last In First Out) to demonstrate the way it accesses data, since as we will see there are various variations of stack implementations.
</p><p>There are basically three operations that can be performed on stacks. They are
1) inserting an item into a stack (push).
2) deleting an item from the stack (pop).
3) displaying the contents of the stack(pip).
</p>
<p>Below are some of operations a <b>stack data type</b> normally supports:
</p>
<div class="interface" style="background-color: black; border: solid 1px #FFC92E; padding: 1em; width:80%" title="Stack&lt;item-type&gt; Operations">
<p><b><code>Stack&lt;item-type&gt;</code> Operations</b>
</p>
<dl>
<dt style="font-weight:normal"><code><b>push</b>(<var>new-item</var>:item-type)</code></dt>
<dd>Adds an item onto the stack.</dd>
<dt style="font-weight:normal"><code><b>top</b>():item-type</code></dt>
<dd>Returns the last item pushed onto the stack.</dd>
<dt style="font-weight:normal"><code><b>pop</b>()</code></dt>
<dd>Removes the most-recently-pushed item from the stack.</dd>
<dt style="font-weight:normal"><code><b>is-empty</b>():Boolean</code></dt>
<dd>True if no more items can be popped and there is no top item.</dd>
<dt style="font-weight:normal"><code><b>is-full</b>():Boolean</code></dt>
<dd>True if no more items can be pushed.</dd>
<dt style="font-weight:normal"><code><b>get-size</b>():Integer</code></dt>
<dd>Returns the number of elements on the stack.</dd>
</dl>
<p>All operations except <code>get-size()</code> can be performed in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle O(1)}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>O</mi>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle O(1)}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e66384bc40452c5452f33563fe0e27e803b0cc21" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:4.745ex; height:2.843ex;" alt="O(1)"/></span> time. <code>get-size()</code> runs in at worst <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle O(N).}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>O</mi>
        <mo stretchy="false">(</mo>
        <mi>N</mi>
        <mo stretchy="false">)</mo>
        <mo>.</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle O(N).}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/221c692848ccee2e02507eded3adfb7c2f7d5fc8" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:6.293ex; height:2.843ex;" alt="O(N)."/></span>
</p>
</div>
<h4><span class="mw-headline" id="Linked_List_Implementation">Linked List Implementation</span></h4>
<p>The basic linked list implementation is one of the easiest stack implementations you can do.  Structurally it is a linked list.
</p>
<pre>type Stack&lt;item_type&gt;
  data list:Singly Linked List&lt;item_type&gt;
"stack follows the LIFO (last in first out) operation"
"queue follows the FIFO (first in first out) operation"
  constructor()
    list&#160;:= new Singly-Linked-List()
  end constructor
</pre>
<p>Most operations are implemented by passing them through to the underlying linked list.
When you want to <b>push</b> something onto the list, you simply add it to the front of the linked list. The previous top is then "next" from the item being added and the list's front pointer points to the new item.
</p>
<pre>  method push(new_item:item_type)
    list.prepend(new_item)
  end method
</pre>
<p>To look at the <b>top</b> item, you just examine the first item in the linked list.
</p>
<pre>  method top():item_type
    return list.get-begin().get-value()
  end method
</pre>
<p>When you want to <b>pop</b> something off the list, simply remove the first item from the linked list.
</p>
<pre>  method pop()
    list.remove-first()
  end method
</pre>
<p>A check for emptiness is easy.  Just check if the list is empty.
</p>
<pre>  method is-empty():Boolean
    return list.is-empty()
  end method
</pre>
<p>A check for full is simple. Linked lists are considered to be limitless in size.
</p>
<pre>  method is-full():Boolean
    return False
  end method
</pre>
<p>A check for the size is again passed through to the list.
</p>
<pre>  method get-size():Integer
    return list.get-size()
  end method
end type
</pre>
<p>A real Stack implementation in a published library would probably re-implement the linked list in order to squeeze the last bit of performance out of the implementation by leaving out unneeded functionality. The above implementation gives you the ideas involved, and any optimization you need can be accomplished by inlining the linked list code.
</p><p><br />
</p>
<h3><span class="mw-headline" id="Applications_of_Stacks">Applications of Stacks</span></h3>
<div class="thumb tright"><div class="thumbinner" style="width:222px;"><a href="/wiki/File:Stack_of_books.jpg" class="image"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Stack_of_books.jpg/330px-Stack_of_books.jpg"></a>  <div class="thumbcaption"><div class="magnify"><a href="/wiki/File:Stack_of_books.jpg" class="internal" title="Enlarge"></a></div>Stack of books</div></div></div>
<p>Using stacks, we can solve many applications, some of which are listed below.
</p>
<h4><span class="mw-headline" id="Converting_a_decimal_number_into_a_binary_number">Converting a decimal number into a binary number</span></h4>
<p>The logic for transforming a decimal number into a binary number is as follows:
</p>
<pre>    * Read a number
    * Iteration (while number is greater than zero)
              1. Find out the remainder after dividing the number by 2
              2. Print the remainder
              3. Divide the number by 2
    * End the iteration
</pre>
<p>However, there is a problem with this logic. Suppose the number whose binary form we want to find is 23. Using this logic, we get the result as 11101, instead of getting 10111.
</p><p>To solve this problem, we use a stack. We make use of the <i>LIFO</i> property of the stack. Initially we <i>push</i> the binary digit formed into the stack, instead of printing it directly. After the entire digit has been converted into the binary form, we <i>pop</i> one digit at a time from the stack and print it. Therefore we get the decimal number is converted into its proper binary form.
</p><p><b>Algorithm:</b>
</p>
<pre>   1. Create a stack
   2. Enter a decimal number which has to be converted into its equivalent binary form.
   3. iteration1 (while number &gt; 0)
         3.1 digit = number&#160;% 2
         3.2 Push <i>digit</i> into the stack
         3.3 If the stack is full
              3.3.1 Print an error
              3.3.2 Stop the algorithm
         3.4 End the <i>if</i> condition
         3.5 Divide the number by 2
   4. End <i>iteration1</i>
   
   5. iteration2 (while stack is not empty)
         5.1 Pop <i>digit</i> from the stack
         5.2 Print the <i>digit</i>
   6. End iteration2
   7. STOP
</pre>
<h4><span class="mw-headline" id="Towers_of_Hanoi">Towers of Hanoi</span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="/wiki/File:Tower_of_Hanoi.jpeg" class="image"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/07/Tower_of_Hanoi.jpeg/450px-Tower_of_Hanoi.jpeg"></a>  <div class="thumbcaption"><div class="magnify"><a href="/wiki/File:Tower_of_Hanoi.jpeg" class="internal" title="Enlarge"></a></div>Towers of Hanoi</div></div></div>
<p>One of the most interesting applications of stacks can be found in solving a puzzle called Tower of Hanoi. According to an old Brahmin story, the existence of the universe is calculated in terms of the time taken by a number of monks, who are working all the time, to move 64 disks from one pole to another. But there are some rules about how this should be done, which are:
</p>
<ol><li>You can move only one disk at a time.</li>
<li>For temporary storage, a third pole may be used.</li>
<li>You cannot place a disk of larger diameter on a disk of smaller diameter.</li></ol>
<p>Here we assume that  A is first tower, B is second tower  &amp; C is third tower.
</p>
<div class="thumb tleft"><div class="thumbinner" style="width:377px;"><a href="/wiki/File:Towersofhanoi1.pdf" class="image"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/Towersofhanoi1.pdf/page1-563px-Towersofhanoi1.pdf.jpg"></a>  <div class="thumbcaption"><div class="magnify"><a href="/wiki/File:Towersofhanoi1.pdf" class="internal" title="Enlarge"></a></div>Towers of Hanoi step 1</div></div></div>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:377px;"><a href="/wiki/File:Towersofhanoi2.pdf" class="image"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/19/Towersofhanoi2.pdf/page1-563px-Towersofhanoi2.pdf.jpg"></a>  <div class="thumbcaption"><div class="magnify"><a href="/wiki/File:Towersofhanoi2.pdf" class="internal" title="Enlarge"></a></div>Towers of Hanoi step 2</div></div></div></div>
<div class="thumb tleft"><div class="thumbinner" style="width:377px;"><a href="/wiki/File:Towersofhanoi3.pdf" class="image"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2d/Towersofhanoi3.pdf/page1-563px-Towersofhanoi3.pdf.jpg"></a>  <div class="thumbcaption"><div class="magnify"><a href="/wiki/File:Towersofhanoi3.pdf" class="internal" title="Enlarge"></a></div>Towers of Hanoi step 3</div></div></div>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:377px;"><a href="/wiki/File:Towersofhanoi4.pdf" class="image"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c4/Towersofhanoi4.pdf/page1-563px-Towersofhanoi4.pdf.jpg"></a>  <div class="thumbcaption"><div class="magnify"><a href="/wiki/File:Towersofhanoi4.pdf" class="internal" title="Enlarge"></a></div>Towers of Hanoi step 4</div></div></div></div>
<div class="thumb tright"><div class="thumbinner" style="width:352px;"><a href="/wiki/File:Towerofhanoi.jpg" class="image"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Towerofhanoi.jpg/525px-Towerofhanoi.jpg"></a></div>Tower of Hanoi</div></div></div>
<p><b>Output&#160;: (when there are 3 disks)</b>
</p><p>Let <i>1</i> be the smallest disk, <i>2</i> be the disk of medium size and <i>3</i> be the largest disk.
</p>
<table class="wikitable sortable">
<tbody><tr>
<th>Move disk
</th>
<th>From peg
</th>
<th>To peg
</th></tr>
<tr>
<td>1
</td>
<td>A
</td>
<td>C
</td></tr>
<tr>
<td>2
</td>
<td>A
</td>
<td>B
</td></tr>
<tr>
<td>1
</td>
<td>C
</td>
<td>B
</td></tr>
<tr>
<td>3
</td>
<td>A
</td>
<td>C
</td></tr>
<tr>
<td>1
</td>
<td>B
</td>
<td>A
</td></tr>
<tr>
<td>2
</td>
<td>B
</td>
<td>C
</td></tr>
<tr>
<td>1
</td>
<td>A
</td>
<td>C
</td></tr></tbody></table>
<p><b>Output&#160;: (when there are 4 disks)</b>
</p>
<table class="wikitable sortable">
<tbody><tr>
<th>Move disk
</th>
<th>From peg
</th>
<th>To peg
</th></tr>
<tr>
<td>1
</td>
<td>A
</td>
<td>B
</td></tr>
<tr>
<td>2
</td>
<td>A
</td>
<td>C
</td></tr>
<tr>
<td>1
</td>
<td>B
</td>
<td>C
</td></tr>
<tr>
<td>3
</td>
<td>A
</td>
<td>B
</td></tr>
<tr>
<td>1
</td>
<td>C
</td>
<td>A
</td></tr>
<tr>
<td>2
</td>
<td>C
</td>
<td>B
</td></tr>
<tr>
<td>1
</td>
<td>A
</td>
<td>B
</td></tr>
<tr>
<td>4
</td>
<td>A
</td>
<td>C
</td></tr>
<tr>
<td>1
</td>
<td>B
</td>
<td>C
</td></tr>
<tr>
<td>2
</td>
<td>B
</td>
<td>A
</td></tr>
<tr>
<td>1
</td>
<td>C
</td>
<td>A
</td></tr>
<tr>
<td>3
</td>
<td>B
</td>
<td>C
</td></tr>
<tr>
<td>1
</td>
<td>A
</td>
<td>B
</td></tr>
<tr>
<td>2
</td>
<td>A
</td>
<td>C
</td></tr>
<tr>
<td>1
</td>
<td>B
</td>
<td>C
</td></tr></tbody></table>
<p>The C++ code for this solution can be implemented in two ways:
</p>
<h5><span id="First_Implementation_.28Without_using_Stacks.29"></span><span class="mw-headline" id="First_Implementation_(Without_using_Stacks)">First Implementation (Without using Stacks)</span></h5>
<p>Here we assume that  A is first tower, B is second tower  &amp; C is third tower. (B is the intermediate)
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span> <span class="nf">TowersofHanoi</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//Move top n disks from tower a to tower b, use tower c for intermediate storage.</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">TowersofHanoi</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>   <span class="c1">//recursion</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; Move top disk from tower &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; to tower &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="p">;</span>
        <span class="c1">//Move n-1 disks from intermediate(b) to the source(a) back</span>
        <span class="n">TowersofHanoi</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>   <span class="c1">//recursion</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h5><span id="Second_Implementation_.28Using_Stacks.29"></span><span class="mw-headline" id="Second_Implementation_(Using_Stacks)">Second Implementation (Using Stacks)</span></h5>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">// Global variable, tower [1:3] are three towers</span>
<span class="n">arrayStack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tower</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">TowerofHanoi</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Preprocessor for moveAndShow.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">d</span><span class="o">--</span><span class="p">)</span>        <span class="c1">//initialize</span>
        <span class="n">tower</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">push</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>              <span class="c1">//add disk d to tower 1</span>
    <span class="n">moveAndShow</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>           <span class="cm">/*move n disks from tower 1 to tower 3 using </span>
<span class="cm">                                       tower 2 as intermediate tower*/</span>  
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">moveAndShow</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Move the top n disks from tower a to tower b showing states.</span>
    <span class="c1">// Use tower c for intermediate storage.</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">moveAndShow</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>     <span class="c1">//recursion</span>
        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">tower</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">top</span><span class="p">();</span>        <span class="c1">//move a disc from top of tower a to top of </span>
        <span class="n">tower</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">pop</span><span class="p">();</span>                <span class="c1">//tower b</span>
        <span class="n">tower</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">push</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
        <span class="n">showState</span><span class="p">();</span>                   <span class="c1">//show state of 3 towers</span>
        <span class="n">moveAndShow</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>     <span class="c1">//recursion</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>However complexity for above written implementations is O(<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle 2^{n}}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <msup>
          <mn>2</mn>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>n</mi>
          </mrow>
        </msup>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle 2^{n}}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8226f30650ee4fe4e640c6d2798127e80e9c160d" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.338ex; width:2.381ex; height:2.343ex;" alt="2^{n}"/></span>). So it's obvious that problem can only be solved for small values of n (generally n &lt;= 30). 
In case of the monks, the number of turns taken to transfer 64 disks, by following the above rules, will be 18,446,744,073,709,551,615; which will surely take a lot of time!!
</p>
<h4><span class="mw-headline" id="Expression_evaluation_and_syntax_parsing">Expression evaluation and syntax parsing</span><span class="mw-editsection"></span></h4>
<p>Calculators employing reverse Polish notation use a stack structure to hold values. Expressions can be represented in prefix, postfix or infix notations. Conversion from one form of the expression to another form may be accomplished using a stack. Many compilers use a stack for parsing the syntax of expressions, program blocks etc. before translating into low level code. Most of the programming languages are context-free languages allowing them to be parsed with stack based machines.
</p>
<h5><span class="mw-headline" id="Evaluation_of_an_Infix_Expression_that_is_Fully_Parenthesized">Evaluation of an Infix Expression that is Fully Parenthesized</span></h5>
<p><b>Input:</b> (((2 * 5) - (1 * 2)) / (9 - 7))
</p><p><b>Output:</b> 4
</p><p><b>Analysis:</b>  Five types of input characters
</p>
<pre>  * Opening bracket
  * Numbers
  * Operators
  * Closing bracket
  * New line character
</pre>
<p><b>Data structure requirement: </b>  A character stack
</p><p><b>Algorithm</b>
</p>
<pre>  1. Read one input character
  2. Actions at end of each input
     Opening brackets              (2.1)  <i>Push</i> into stack and then Go to step (1)
     Number                        (2.2)  <i>Push</i> into stack and then Go to step (1)
     Operator                      (2.3)  <i>Push</i> into stack and then Go to step (1)
     Closing brackets              (2.4)  <i>Pop</i> it from character stack
                                   (2.4.1) if it is opening bracket, then discard it, Go to step (1)
                                   (2.4.2) <i>Pop</i> is used three times
                                           The first popped element is assigned to op2
                                           The second popped element is assigned to op
                                           The third popped element is assigned to op1
                                           Evaluate op1 op op2
                                           Convert the result into character and 
                                           <i>push</i> into the stack
                                           Go to step (2.4)
    New line character            (2.5)  <i>Pop</i> from stack and print the answer
                                         <i>STOP</i>
</pre>
<p><b>Result:</b>  The evaluation of the fully parenthesized infix expression is printed on the monitor as follows:
</p><p><b>Input String: </b>  (((2 * 5) - (1 * 2)) / (9 - 7))
</p>
<table class="wikitable sortable">
<tbody><tr>
<th>Input Symbol
</th>
<th>Stack (from bottom to top)
</th>
<th>Operation
</th></tr>
<tr>
<td>(
</td>
<td>(
</td>
<td>
</td></tr>
<tr>
<td>(
</td>
<td>( (
</td>
<td>
</td></tr>
<tr>
<td>(
</td>
<td>( ( (
</td>
<td>
</td></tr>
<tr>
<td>2
</td>
<td>( ( ( 2
</td>
<td>
</td></tr>
<tr>
<td>*
</td>
<td>( ( ( 2 *
</td>
<td>
</td></tr>
<tr>
<td>5
</td>
<td>( ( ( 2 * 5
</td>
<td>
</td></tr>
<tr>
<td>)
</td>
<td>( ( 10
</td>
<td>2 * 5 = 10 &amp; <i>Push</i>
</td></tr>
<tr>
<td>-
</td>
<td>( ( 10 -
</td>
<td>
</td></tr>
<tr>
<td>(
</td>
<td>( ( 10 - (
</td>
<td>
</td></tr>
<tr>
<td>1
</td>
<td>( ( 10 - ( 1
</td>
<td>
</td></tr>
<tr>
<td>*
</td>
<td>( ( 10 - ( 1 *
</td>
<td>
</td></tr>
<tr>
<td>2
</td>
<td>( ( 10 - ( 1 * 2
</td>
<td>
</td></tr>
<tr>
<td>)
</td>
<td>( ( 10 - 2
</td>
<td>1 * 2 = 2 &amp; <i>Push</i>
</td></tr>
<tr>
<td>)
</td>
<td>( 8
</td>
<td>10 - 2 = 8 &amp; <i>Push</i>
</td></tr>
<tr>
<td>/
</td>
<td>( 8 /
</td>
<td>
</td></tr>
<tr>
<td>(
</td>
<td>( 8 / (
</td>
<td>
</td></tr>
<tr>
<td>9
</td>
<td>( 8 / ( 9
</td>
<td>
</td></tr>
<tr>
<td>-
</td>
<td>( 8 / ( 9 -
</td>
<td>
</td></tr>
<tr>
<td>9
</td>
<td>( 8 / ( 9 - 7
</td>
<td>
</td></tr>
<tr>
<td>)
</td>
<td>( 8 / 2
</td>
<td>9 - 7 = 2 &amp; <i>Push</i>
</td></tr>
<tr>
<td>)
</td>
<td>4
</td>
<td>8 / 2 = 4 &amp; <i>Push</i>
</td></tr>
<tr>
<td>New line
</td>
<td>Empty
</td>
<td><i>Pop</i> &amp; Print
</td></tr></tbody></table>
<p><b>C Program</b>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">int</span> <span class="n">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span>
     <span class="k">struct</span> <span class="n">ch</span> <span class="o">*</span><span class="n">charactop</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">integer</span> <span class="o">*</span><span class="n">integertop</span><span class="p">;</span>
     <span class="kt">char</span> <span class="n">rd</span><span class="p">,</span> <span class="n">op</span><span class="p">;</span>
     <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">;</span>
     <span class="n">charactop</span> <span class="o">=</span> <span class="n">cclearstack</span><span class="p">();</span>
     <span class="n">integertop</span> <span class="o">=</span> <span class="n">iclearstack</span><span class="p">();</span>
     <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
     <span class="p">{</span>
         <span class="n">rd</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
         <span class="k">switch</span><span class="p">(</span><span class="n">rd</span><span class="p">)</span>
         <span class="p">{</span>
             <span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="o">:</span>
             <span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="o">:</span>
             <span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="o">:</span>
             <span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="o">:</span>
             <span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="o">:</span> <span class="n">charactop</span> <span class="o">=</span> <span class="n">cpush</span><span class="p">(</span><span class="n">charactop</span><span class="p">,</span> <span class="n">rd</span><span class="p">);</span>
             <span class="k">break</span><span class="p">;</span>
             <span class="k">case</span> <span class="sc">&#39;)&#39;</span><span class="o">:</span> <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipop</span> <span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op2</span><span class="p">);</span>
                       <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipop</span> <span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op1</span><span class="p">);</span>
                       <span class="n">charactop</span> <span class="o">=</span> <span class="n">cpop</span> <span class="p">(</span><span class="n">charactop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">);</span>
                       <span class="k">while</span><span class="p">(</span><span class="n">op</span> <span class="o">!=</span> <span class="sc">&#39;(&#39;</span><span class="p">)</span>
                       <span class="p">{</span>
                           <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipush</span> <span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="n">eval</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">));</span>
                           <span class="n">charactop</span> <span class="o">=</span> <span class="n">cpop</span> <span class="p">(</span><span class="n">charactop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">);</span>
                           <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">!=</span> <span class="sc">&#39;(&#39;</span><span class="p">)</span>
                           <span class="p">{</span>
                               <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipop</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op2</span><span class="p">);</span>
                               <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipop</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op1</span><span class="p">);</span>
                           <span class="p">}</span>
                       <span class="p">}</span>
                       <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">&#39;\0&#39;</span><span class="o">:</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span> <span class="n">cemptystack</span><span class="p">(</span><span class="n">charactop</span><span class="p">))</span>
                       <span class="p">{</span>
                           <span class="n">charactop</span> <span class="o">=</span> <span class="n">cpop</span><span class="p">(</span><span class="n">charactop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">);</span>
                           <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipop</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op2</span><span class="p">);</span>
                           <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipop</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op1</span><span class="p">);</span>
                           <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipush</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="n">eval</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">));</span>
                       <span class="p">}</span>
                       <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipop</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op1</span><span class="p">);</span>
                       <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s"> The final solution is: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op1</span><span class="p">);</span>
                       <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
           <span class="k">default</span><span class="o">:</span> <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipush</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="n">rd</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
           <span class="p">}</span>
      <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">eval</span><span class="p">(</span><span class="kt">char</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="p">{</span>
         <span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="n">op1</span> <span class="o">+</span> <span class="n">op2</span><span class="p">;</span>
         <span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="n">op1</span> <span class="o">-</span> <span class="n">op2</span><span class="p">;</span>
         <span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="n">op1</span> <span class="o">/</span> <span class="n">op2</span><span class="p">;</span>
         <span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="n">op1</span> <span class="o">*</span> <span class="n">op2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p><b>Output of the program:</b>
</p>
<p>Input entered at the command line: (((2 * 5) - (1 * 2)) / (9 - 7))</p>

<h5><span class="mw-headline" id="Evaluation_of_Infix_Expression_which_is_not_fully_parenthesized">Evaluation of Infix Expression which is not fully parenthesized</span></h5>
<p><b>Input:</b> (2 * 5 - 1 * 2) / (11 - 9)
</p><p><b>Output:</b> 4
</p><p><b>Analysis:</b> There are five types of input characters which are:
</p>
<pre>               * Opening brackets
               * Numbers
               * Operators
               * Closing brackets
               * New line character (\n)
</pre>
<p>We do not know what to do if an operator is read as an input character.
By implementing the priority rule for operators, we have a solution to this problem.
</p><p>The <i>Priority rule</i> we should perform comparative priority check if an operator is read, and then push it. If the stack <i>top</i> contains an operator of prioirty higher than or equal to the priority of the input operator, then we <i>pop</i> it and print it. We keep on perforrming the prioirty check until the <i>top</i> of stack either contains an operator of lower priority or if it does not contain an operator.
</p><p><b>Data Structure Requirement for this problem:</b> A character stack and an integer stack
</p><p><b>Algorithm:</b>
</p>
<pre>   1. Read an input character
   2. Actions that will be performed at the end of each input
      Opening brackets              (2.1)  <i>Push</i> it into stack and then Go to step (1)  
      Digit                         (2.2)  <i>Push</i> into stack, Go to step (1)
      Operator                      (2.3)  Do the comparative priority check
                                    (2.3.1) if the character stack's <i>top</i> contains an operator with equal
                                             or higher priority, then <i>pop</i> it into op
                                             <i>Pop</i> a number from integer stack into op2
                                             <i>Pop</i> another number from integer stack into op1
                                           Calculate op1 op op2 and <i>push</i> the result into the integer
                                           stack
     Closing brackets              (2.4)  <i>Pop</i> from the character stack
                                   (2.4.1) if it is an opening bracket, then discard it and Go to
                                           step (1)
                                   (2.4.2) To op, assign the popped element
                                           <i>Pop</i> a number from integer stack and assign it op2
                                           <i>Pop</i> another number from integer stack and assign it
                                           to op1
                                           Calculate <i>op1</i> <i>op</i> <i>op2</i> and push the result into the integer
                                           stack
                                           Convert into character and <i>push</i> into stack
                                           Go to the step (2.4)
    New line character            (2.5)  Print the result after popping from the stack
                                         <i>STOP</i>
</pre>
<p><b>Result:</b>  The evaluation of an infix expression that is not fully parenthesized is printed as follows:
</p><p><b>Input String: </b>  (2 * 5 - 1 * 2) / (11 - 9)
</p>
<table class="wikitable sortable">
<tbody><tr>
<th>Input Symbol
</th>
<th>Character Stack (from bottom to top)
</th>
<th>Integer Stack (from bottom to top)
</th>
<th>Operation performed
</th></tr>
<tr>
<td>(
</td>
<td>(
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td>2
</td>
<td>(
</td>
<td>2
</td>
<td>
</td></tr>
<tr>
<td>*
</td>
<td>( *
</td>
<td>
</td>
<td><i>Push</i> as * has higher priority
</td></tr>
<tr>
<td>5
</td>
<td>( *
</td>
<td>2  5
</td>
<td>
</td></tr>
<tr>
<td>-
</td>
<td>( *
</td>
<td>
</td>
<td>Since '-' has less priority, we do 2 * 5 = 10
</td></tr>
<tr>
<td>
</td>
<td>( -
</td>
<td>10
</td>
<td>We push 10 and then push '-'
</td></tr>
<tr>
<td>1
</td>
<td>( -
</td>
<td>10  1
</td>
<td>
</td></tr>
<tr>
<td>*
</td>
<td>( - *
</td>
<td>10  1
</td>
<td>Push * as it has higher priority
</td></tr>
<tr>
<td>2
</td>
<td>( - *
</td>
<td>10  1  2
</td>
<td>
</td></tr>
<tr>
<td>)
</td>
<td>( -
</td>
<td>10  2
</td>
<td>Perform 1 * 2 = 2 and push it
</td></tr>
<tr>
<td>
</td>
<td>(
</td>
<td>8
</td>
<td>Pop - and 10 - 2 = 8 and push, Pop (
</td></tr>
<tr>
<td>/
</td>
<td>/
</td>
<td>8
</td>
<td>
</td></tr>
<tr>
<td>(
</td>
<td>/ (
</td>
<td>8
</td>
<td>
</td></tr>
<tr>
<td>11
</td>
<td>/ (
</td>
<td>8  11
</td>
<td>
</td></tr>
<tr>
<td>-
</td>
<td>/ ( -
</td>
<td>8  11
</td>
<td>
</td></tr>
<tr>
<td>9
</td>
<td>/ ( -
</td>
<td>8  11  9
</td>
<td>
</td></tr>
<tr>
<td>)
</td>
<td>/
</td>
<td>8  2
</td>
<td>Perform 11 - 9 = 2 and push it
</td></tr>
<tr>
<td>New line
</td>
<td>
</td>
<td>4
</td>
<td>Perform 8 / 2 = 4 and push it
</td></tr>
<tr>
<td>
</td>
<td>
</td>
<td>4
</td>
<td>Print the output, which is 4
</td></tr></tbody></table>
<p><b>C Program</b>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
     <span class="k">struct</span> <span class="n">ch</span> <span class="o">*</span><span class="n">charactop</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">integer</span> <span class="o">*</span><span class="n">integertop</span><span class="p">;</span>
     <span class="kt">char</span> <span class="n">rd</span><span class="p">,</span> <span class="n">op</span><span class="p">;</span>
     <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">;</span>
     <span class="n">charactop</span> <span class="o">=</span> <span class="n">cclearstack</span><span class="p">();</span>
     <span class="n">integertop</span> <span class="o">=</span> <span class="n">iclearstack</span><span class="p">();</span>
     <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
     <span class="p">{</span>
         <span class="n">rd</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
         <span class="k">switch</span><span class="p">(</span><span class="n">rd</span><span class="p">)</span>
         <span class="p">{</span>
             <span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="o">:</span>
             <span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="o">:</span>
             <span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="o">:</span>
             <span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="o">:</span> <span class="k">while</span> <span class="p">((</span><span class="n">charactop</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="sc">&#39;(&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">cemptystack</span><span class="p">(</span><span class="n">charactop</span><span class="p">)))</span>
                       <span class="p">{</span>
                            <span class="k">if</span><span class="p">(</span><span class="n">priority</span><span class="p">(</span><span class="n">rd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">priority</span><span class="p">(</span><span class="n">charactop</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span>
                                <span class="k">break</span><span class="p">;</span>
                            <span class="k">else</span>
                            <span class="p">{</span>
                                <span class="n">charactop</span> <span class="o">=</span> <span class="n">cpop</span><span class="p">(</span><span class="n">charactop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">);</span>
                                <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipop</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op2</span><span class="p">);</span>
                                <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipop</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op1</span><span class="p">);</span>
                                <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipush</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="n">eval</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">);</span>
                            <span class="p">}</span>
                       <span class="p">}</span>
                       <span class="n">charactop</span> <span class="o">=</span> <span class="n">cpush</span><span class="p">(</span><span class="n">charactop</span><span class="p">,</span> <span class="n">rd</span><span class="p">);</span>
                       <span class="k">break</span><span class="p">;</span>
             <span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="o">:</span> <span class="n">charactop</span> <span class="o">=</span> <span class="n">cpush</span><span class="p">(</span><span class="n">charactop</span><span class="p">,</span> <span class="n">rd</span><span class="p">);</span>
             <span class="k">break</span><span class="p">;</span>
             <span class="k">case</span> <span class="sc">&#39;)&#39;</span><span class="o">:</span> <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipop</span> <span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op2</span><span class="p">);</span>
                       <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipop</span> <span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op1</span><span class="p">);</span>
                       <span class="n">charactop</span> <span class="o">=</span> <span class="n">cpop</span> <span class="p">(</span><span class="n">charactop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">);</span>
                       <span class="k">while</span><span class="p">(</span><span class="n">op</span> <span class="o">!=</span> <span class="sc">&#39;(&#39;</span><span class="p">)</span>
                       <span class="p">{</span>
                           <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipush</span> <span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="n">eval</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">);</span>
                           <span class="n">charactop</span> <span class="o">=</span> <span class="n">cpop</span> <span class="p">(</span><span class="n">charactop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">);</span>
                           <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">!=</span> <span class="sc">&#39;(&#39;</span><span class="p">)</span>
                           <span class="p">{</span>
                               <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipop</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op2</span><span class="p">);</span>
                               <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipop</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op1</span><span class="p">);</span>
                           <span class="p">}</span>
                       <span class="p">}</span>
                       <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">&#39;\0&#39;</span><span class="o">:</span> <span class="k">while</span> <span class="p">(</span><span class="o">!=</span> <span class="n">cemptystack</span><span class="p">(</span><span class="n">charactop</span><span class="p">))</span>
                       <span class="p">{</span>
                           <span class="n">charactop</span> <span class="o">=</span> <span class="n">cpop</span><span class="p">(</span><span class="n">charactop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">);</span>
                           <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipop</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op2</span><span class="p">);</span>
                           <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipop</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op1</span><span class="p">);</span>
                           <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipush</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="n">eval</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">);</span>
                       <span class="p">}</span>
                       <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipop</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op1</span><span class="p">);</span>
                       <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s"> The final solution is: %d&quot;</span><span class="p">,</span> <span class="n">op1</span><span class="p">);</span>
                       <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
           <span class="k">default</span><span class="o">:</span> <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipush</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="n">rd</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
           <span class="p">}</span>
      <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">eval</span><span class="p">(</span><span class="kt">char</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="p">{</span>
         <span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="n">op1</span> <span class="o">+</span> <span class="n">op2</span><span class="p">;</span>
         <span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="n">op1</span> <span class="o">-</span> <span class="n">op2</span><span class="p">;</span>
         <span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="n">op1</span> <span class="o">/</span> <span class="n">op2</span><span class="p">;</span>
         <span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="n">op1</span> <span class="o">*</span> <span class="n">op2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">priority</span> <span class="p">(</span><span class="kt">char</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">switch</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">case</span> <span class="sc">&#39;^&#39;</span><span class="o">:</span>
      <span class="k">case</span> <span class="sc">&#39;$&#39;</span><span class="o">:</span>  <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
      <span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="o">:</span>
      <span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="o">:</span>  <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
      <span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="o">:</span>
      <span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p><b>Output of the program:</b>
</p><p><i>Input entered at the command line:</i> (2 * 5 - 1 * 2) / (11 - 9)
</p><p><i>Output:</i> 4</p>
<h5><span class="mw-headline" id="Evaluation_of_Prefix_Expression">Evaluation of Prefix Expression</span></span></h5>
<p><b>Input:</b> x + 6 * ( y + z ) ^ 3
</p><p><i>Output:'</i> 4
</p><p><b>Analysis:</b> There are three types of input characters
</p>
<pre>               * Numbers
               * Operators
               * New line character (\n)
</pre>
<p><b>Data structure requirement:</b> A character stack and an integer stack
</p><p><b>Algorithm:</b>
</p>
<pre>   1. Read one character input at a time and keep pushing it into the character stack until the new
      line character is reached
   2. Perform <i>pop</i> from the character stack. If the stack is empty, go to step (3)
      Number                        (2.1) <i>Push</i> in to the integer stack and then go to step (1) 
      Operator                      (2.2)  Assign the operator to op
                                           <i>Pop</i> a number from  integer stack and assign it to op1
                                           <i>Pop</i> another number from integer stack
                                           and assign it to op2                               
                                           Calculate op1 op op2 and push the output into the integer
                                           stack. Go to step (2)                                       
   3. <i>Pop</i> the result from the integer stack and display the result
                       
</pre>
<p><b>Result:</b>  The evaluation of prefix expression is printed as follows:
</p><p><b>Input String: </b> / - * 2 5 * 1 2 - 11 9
</p>
<table class="wikitable sortable">
<tbody><tr>
<th>Input Symbol
</th>
<th>Character Stack (from bottom to top)
</th>
<th>Integer Stack (from bottom to top)
</th>
<th>Operation performed
</th></tr>
<tr>
<td>/
</td>
<td>/
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td>-
</td>
<td>/
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td>*
</td>
<td>/ - *
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td>2
</td>
<td>/ - * 2
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td>5
</td>
<td>/ - * 2  5
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td>*
</td>
<td>/ - * 2  5 *
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td>1
</td>
<td>/ - * 2  5 * 1
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td>2
</td>
<td>/ - * 2  5 * 1  2
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td>-
</td>
<td>/ - * 2  5 * 1  2 -
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td>11
</td>
<td>/ - * 2  5 * 1  2 - 11
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td>9
</td>
<td>/ - * 2  5 * 1  2 - 11  9
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td>\n
</td>
<td>/ - * 2  5 * 1  2 - 11
</td>
<td>9
</td>
<td>
</td></tr>
<tr>
<td>
</td>
<td>/ - * 2  5 * 1  2 -
</td>
<td>9  11
</td>
<td>
</td></tr>
<tr>
<td>
</td>
<td>/ - * 2  5 * 1  2
</td>
<td>2
</td>
<td>11 - 9 = 2
</td></tr>
<tr>
<td>
</td>
<td>/ - * 2  5 * 1
</td>
<td>2  2
</td>
<td>
</td></tr>
<tr>
<td>
</td>
<td>/ - * 2  5 *
</td>
<td>2  2  1
</td>
<td>
</td></tr>
<tr>
<td>
</td>
<td>/ - * 2  5
</td>
<td>2  2
</td>
<td>1 * 2 = 2
</td></tr>
<tr>
<td>
</td>
<td>/ - * 2
</td>
<td>2  2  5
</td>
<td>
</td></tr>
<tr>
<td>
</td>
<td>/ - *
</td>
<td>2  2  5  2
</td>
<td>
</td></tr>
<tr>
<td>
</td>
<td>/ -
</td>
<td>2  2  10
</td>
<td>5 * 2 = 10
</td></tr>
<tr>
<td>
</td>
<td>/
</td>
<td>2  8
</td>
<td>10 - 2 = 8
</td></tr>
<tr>
<td>
</td>
<td>Stack is empty
</td>
<td>4
</td>
<td>8 / 2 = 4
</td></tr>
<tr>
<td>
</td>
<td>
</td>
<td>Stack is empty
</td>
<td>Print 4
</td></tr></tbody></table>
<p><b>C Program</b>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
     <span class="k">struct</span> <span class="n">ch</span> <span class="o">*</span><span class="n">charactop</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">integer</span> <span class="o">*</span><span class="n">integertop</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
     <span class="kt">char</span> <span class="n">rd</span><span class="p">,</span> <span class="n">op</span><span class="p">;</span>
     <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">;</span>
     <span class="n">charactop</span> <span class="o">=</span> <span class="n">cclearstack</span><span class="p">();</span>
     <span class="n">integertop</span> <span class="o">=</span> <span class="n">iclearstack</span><span class="p">();</span>
     <span class="n">rd</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
     <span class="k">while</span><span class="p">(</span><span class="n">rd</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
     <span class="p">{</span>
         <span class="n">charactop</span> <span class="o">=</span> <span class="n">cpush</span><span class="p">(</span><span class="n">charactop</span><span class="p">,</span> <span class="n">rd</span><span class="p">);</span>
         <span class="n">rd</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">emptystack</span><span class="p">(</span><span class="n">charactop</span><span class="p">))</span>
      <span class="p">{</span>
           <span class="n">charactop</span> <span class="o">=</span> <span class="n">cpop</span><span class="p">(</span><span class="n">charactop</span><span class="p">,</span> <span class="n">rd</span><span class="p">);</span>
           <span class="k">switch</span><span class="p">(</span><span class="n">rd</span><span class="p">)</span>
           <span class="p">{</span>
              <span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="o">:</span> 
                            <span class="n">op</span> <span class="o">=</span> <span class="n">rd</span><span class="p">;</span>
                            <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipop</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op2</span><span class="p">);</span>
                            <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipop</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op1</span><span class="p">);</span>
                            <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipush</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="n">eval</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">));</span>
              <span class="k">break</span><span class="p">;</span>

              <span class="k">default</span><span class="o">:</span>      <span class="n">integertop</span> <span class="o">=</span> <span class="n">ipush</span><span class="p">(</span><span class="n">integertop</span><span class="p">,</span> <span class="n">rd</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
           <span class="p">}</span>
       <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">eval</span><span class="p">(</span><span class="kt">char</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="p">{</span>
         <span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="n">op1</span> <span class="o">+</span> <span class="n">op2</span><span class="p">;</span>
         <span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="n">op1</span> <span class="o">-</span> <span class="n">op2</span><span class="p">;</span>
         <span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="n">op1</span> <span class="o">/</span> <span class="n">op2</span><span class="p">;</span>
         <span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="n">op1</span> <span class="o">*</span> <span class="n">op2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">priority</span> <span class="p">(</span><span class="kt">char</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">switch</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">case</span> <span class="sc">&#39;^&#39;</span><span class="o">:</span>
      <span class="k">case</span> <span class="sc">&#39;$&#39;</span><span class="o">:</span>  <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
      <span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="o">:</span>
      <span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="o">:</span>  <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
      <span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="o">:</span>
      <span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p><b>Output of the program:</b>
</p><p>Input entered at the command line: / - * 2  5 * 1  2 - 11  9</p>
<p>Output: 4
</p>
<h4><span class="mw-headline" id="Conversion_of_an_Infix_expression_that_is_fully_parenthesized_into_a_Postfix_expression">Conversion of an Infix expression that is fully parenthesized into a Postfix expression</span></span></h4>
<p><b>Input:</b> (((8 + 1) - (7 - 4)) / (11 - 9))
</p><p><b>Output:</b> 8 1 + 7 4 - - 11 9 - /
</p><p><b>Analysis:</b>  There are five types of input characters which are:
</p>
<pre>               * Opening brackets
               * Numbers
               * Operators
               * Closing brackets
               * New line character (\n)
</pre>
<p><b>Requirement:</b> A character stack
</p><p><b>Algorithm:</b>
</p>
<pre>   1. Read an character input
   2. Actions to be performed at end of each input
     Opening brackets              (2.1)  <i>Push</i> into stack and then Go to step (1)
     Number                        (2.2)  Print and then Go to step (1)
     Operator                      (2.3)  <i>Push</i> into stack and then Go to step (1)
     Closing brackets              (2.4)  <i>Pop</i> it from the stack
                                   (2.4.1) If it is an operator, print it, Go to step (1)
                                   (2.4.2) If the popped element is an opening bracket,
                                           discard it and go to step (1)           
     New line character            (2.5)  <i>STOP</i>
</pre>
<p>Therefore, the final output after conversion of an infix expression to a postfix expression is as follows:
</p><p><br />    
</p>
<table class="wikitable sortable">
<tbody><tr>
<th>Input
</th>
<th>Operation
</th>
<th>Stack (after op)
</th>
<th>Output on monitor
</th></tr>
<tr>
<td>(
</td>
<td>(2.1) Push operand into stack
</td>
<td>(
</td>
<td>
</td></tr>
<tr>
<td>(
</td>
<td>(2.1) Push operand into stack
</td>
<td>( (
</td>
<td>
</td></tr>
<tr>
<td>(
</td>
<td>(2.1) Push operand into stack
</td>
<td>( ( (
</td>
<td>
</td></tr>
<tr>
<td>8
</td>
<td>(2.2) Print it
</td>
<td>
</td>
<td>8
</td></tr>
<tr>
<td>+
</td>
<td>(2.3) Push operator into stack
</td>
<td>( ( ( +
</td>
<td>8
</td></tr>
<tr>
<td>1
</td>
<td>(2.2) Print it
</td>
<td>
</td>
<td>8 1
</td></tr>
<tr>
<td>)
</td>
<td>(2.4) Pop from the stack: Since popped element is '+' print it
</td>
<td>( ( (
</td>
<td>8 1 +
</td></tr>
<tr>
<td>
</td>
<td>(2.4) Pop from the stack: Since popped element is '(' we ignore it and read next character
</td>
<td>( (
</td>
<td>8 1 +
</td></tr>
<tr>
<td>-
</td>
<td>(2.3) Push operator into stack
</td>
<td>( ( -
</td>
<td>
</td></tr>
<tr>
<td>(
</td>
<td>(2.1) Push operand into stack
</td>
<td>( ( - (
</td>
<td>
</td></tr>
<tr>
<td>7
</td>
<td>(2.2) Print it
</td>
<td>
</td>
<td>8 1 + 7
</td></tr>
<tr>
<td>-
</td>
<td>(2.3) Push the operator in the stack
</td>
<td>( ( - ( -
</td>
<td>
</td></tr>
<tr>
<td>4
</td>
<td>(2.2) Print it
</td>
<td>
</td>
<td>8 1 + 7 4
</td></tr>
<tr>
<td>)
</td>
<td>(2.4) Pop from the stack: Since popped element is '-' print it
</td>
<td>( ( - (
</td>
<td>8 1 +  7 4 -
</td></tr>
<tr>
<td>
</td>
<td>(2.4) Pop from the stack: Since popped element is '(' we ignore it and read next character
</td>
<td>( ( -
</td></tr>
<tr>
<td>)
</td>
<td>(2.4) Pop from the stack: Since popped element is '-' print it
</td>
<td>( (
</td>
<td>8 1 + 7 4 - -
</td></tr>
<tr>
<td>
</td>
<td>(2.4) Pop from the stack: Since popped element is '(' we ignore it and read next character
</td>
<td>(
</td>
<td>
</td></tr>
<tr>
<td>/
</td>
<td>(2.3) Push the operand into the stack
</td>
<td>( /
</td>
<td>
</td></tr>
<tr>
<td>(
</td>
<td>(2.1) Push into the stack
</td>
<td>( / (
</td>
<td>
</td></tr>
<tr>
<td>11
</td>
<td>(2.2) Print it
</td>
<td>
</td>
<td>8 1 + 7 4 - - 11
</td></tr>
<tr>
<td>-
</td>
<td>(2.3) Push the operand into the stack
</td>
<td>( / ( -
</td>
<td>
</td></tr>
<tr>
<td>9
</td>
<td>(2.2) Print it
</td>
<td>
</td>
<td>8 1 + 7 4 - - 11 9
</td></tr>
<tr>
<td>)
</td>
<td>(2.4) Pop from the stack: Since popped element is '-' print it
</td>
<td>( / (
</td>
<td>8 1 + 7 4 - - 11 9 -
</td></tr>
<tr>
<td>
</td>
<td>(2.4) Pop from the stack: Since popped element is '(' we ignore it and read next character
</td>
<td>( /
</td>
<td>
</td></tr>
<tr>
<td>)
</td>
<td>(2.4) Pop from the stack: Since popped element is '/' print it
</td>
<td>(
</td>
<td>8 1 + 7 4 - - 11 9 - /
</td></tr>
<tr>
<td>
</td>
<td>(2.4) Pop from the stack: Since popped element is '(' we ignore it and read next character
</td>
<td>Stack is empty
</td>
<td>
</td></tr>
<tr>
<td>New line character
</td>
<td>(2.5) STOP
</td>
<td>
</td>
<td>
</td></tr></tbody></table>
<h3><span class="mw-headline" id="Queues">Queues</span><span class="mw-editsection"><span class="mw-editsection-bracket"></span></h3>
<p>A queue is a basic data structure that is used throughout programming.  You can think of it as a line in a grocery store.  The first one in the line is the first one to be served.Just like a queue.
</p><p>A queue is also called a FIFO (First In First Out) to demonstrate the way it accesses data.
</p>
<div class="interface" style="background-color: black; border: solid 1px #FFC92E; padding: 1em; width:80%" title="Queue&lt;item-type&gt; Operations">
<p><b><code>Queue&lt;item-type&gt;</code> Operations</b>
</p>
<dl>
<dt style="font-weight:normal"><code><b>enqueue</b>(<var>new-item</var>:item-type)</code></dt>
<dd>Adds an item onto the end of the queue.</dd>
<dt style="font-weight:normal"><code><b>front</b>():item-type</code></dt>
<dd>Returns the item at the front of the queue.</dd>
<dt style="font-weight:normal"><code><b>dequeue</b>()</code></dt>
<dd>Removes the item from the front of the queue.</dd>
<dt style="font-weight:normal"><code><b>is-empty</b>():Boolean</code></dt>
<dd>True if no more items can be dequeued and there is no front item.</dd>
<dt style="font-weight:normal"><code><b>is-full</b>():Boolean</code></dt>
<dd>True if no more items can be enqueued.</dd>
<dt style="font-weight:normal"><code><b>get-size</b>():Integer</code></dt>
<dd>Returns the number of elements in the queue.</dd>
</dl>
<p>All operations except <code>get-size()</code> can be performed in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle O(1)}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>O</mi>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle O(1)}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e66384bc40452c5452f33563fe0e27e803b0cc21" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:4.745ex; height:2.843ex;" alt="O(1)"/></span> time. <code>get-size()</code> runs in at worst <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle O(N).}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>O</mi>
        <mo stretchy="false">(</mo>
        <mi>N</mi>
        <mo stretchy="false">)</mo>
        <mo>.</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle O(N).}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/221c692848ccee2e02507eded3adfb7c2f7d5fc8" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:6.293ex; height:2.843ex;" alt="O(N)."/></span>
</p>
</div>
<h4><span class="mw-headline" id="Linked_List_Implementation_2">Linked List Implementation</span><span class="mw-editsection"><span class="mw-editsection-bracket"></span></h4>
<p>The basic linked list implementation uses a singly-linked list with a tail pointer to keep track of the back of the queue.
</p>
<pre>type Queue&lt;item_type&gt;
  data list:Singly Linked List&lt;item_type&gt;
  data tail:List Iterator&lt;item_type&gt;

  constructor()
    list&#160;:= new Singly-Linked-List()
    tail&#160;:= list.get-begin() # null
  end constructor
</pre>
<p>When you want to <b>enqueue</b> something, you simply add it to the back of the item pointed to by the tail pointer.  So the previous tail is considered next compared to the item being added and the tail pointer points to the new item. If the list was empty, this doesn't work, since the tail iterator doesn't refer to anything
</p>
<pre> method enqueue(new_item:item_type)
   if is-empty()
     list.prepend(new_item)
     tail&#160;:= list.get-begin()
   else
     list.insert_after(new_item, tail)
     tail.move-next()
   end if
 end method
</pre>
<p>The <b>front</b> item on the queue is just the one referred to by the linked list's head pointer
</p>
<pre>  method front():item_type
    return list.get-begin().get-value()
  end method
</pre>
<p>When you want to <b>dequeue</b> something off the list, simply point the head pointer to the previous from head item.  The old head item is the one you removed of the list. If the list is now empty, we have to fix the tail iterator.
</p>
<pre>  method dequeue()
    list.remove-first()
    if is-empty()
      tail&#160;:= list.get-begin()
    end if
  end method
</pre>
<p>A check for emptiness is easy.  Just check if the list is empty.
</p>
<pre>  method is-empty():Boolean
    return list.is-empty()
  end method
</pre>
<p>A check for full is simple.  Linked lists are considered to be limitless in size.
</p>
<pre>  method is-full():Boolean
    return False
  end method
</pre>
<p>A check for the size is again passed through to the list.
</p>
<pre>  method get-size():Integer
    return list.get-size()
  end method
end type
</pre></body>
</html>
